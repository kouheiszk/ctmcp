
## 2.8 進んだ話

宣言的モデルをより深く理解するための追加的な情報、トレードオフ、それらの変種について。

### 2.8.1 関数型プログラミング言語

関数型プログラミングとは完全地についての関数を定義すること。
ここで言う関数は、数学的な意味における関数。
これが計算するための唯一の方法であるような言語を純粋型言語という。

#### ラムダ計算

純粋関数型言語はλ計算という形式化にもとづいている。
さまざまな変種がλ計算にはあるが、それらには共通の
- 関数を定義すること
- 関数を計算すること
という2つの操作がある。

関数値 fun {$ X} X*X end は、λ式 λx. x*x に等しい。
λ式はドットの前のx(関数の引数)と、式x*x(関数の結果)から成る。

#### 宣言的モデルを制限すること

宣言的モデルは
- (束縛されていない変数を含む)部分値の上で関数を定義する
- 手続き的構文を使用する
点において、λ計算より一般的である。

宣言的モデルの構文に2つの制限をおいて、常に完全値について関数を計算するようにすると、純粋関数型言語を定義できる。

- 変数を制限するとき、直ちに値に束縛する
    - local文は必ず次の2つのいずれかになる
        - local <x>=<v> in <s> end
        - local <x>={<y> <y>1 … <y>n} in <s> end
- 手続きでなく関数だけを使う
    - データ構造中の関数呼び出しについては、データ構造を生成する前に入れ子の呼び出しを行う

これにより、束縛されていない変数をデータ構造に入れることが避けられ、束縛されていない変数は宣言的モデルに不要になる。
こういう制限を課した宣言的モデルを（正格）関数型モデルという。
このモデルは、公開プログラミング技法のすべてが可能である。
パターンマッチングはcase文を使ってできる。

#### 関数型プログラミングの変種

この章の関数型モデルはSheme同様動的型付けである。
多くの関数型言語は静的型付けで、それらの多くの静的型付け言語は型推論を行う。
型推論はコンパイラがすべての関数の方を推測するものである。

データフロー変数と単一格納域のおかげで、たいていの関数型言語にないプログラミング技法
- ある種の末尾呼び出し最適化
- 部分値についての計算(3章)
がこの宣言的モデルには許される。

宣言的並列モデル(4章)により、関数的プログラミングの好ましい性質を保ちながら並列性が追加される
- データフロー変数
- 単一代入格納域
のおかげ

宣言的モデルにおいて、関数の引数は関数本体の実行前に計算される。
これは正格計算ともいわれる。
もう一つの有用な計算方式に遅延計算がある。
これは関数の引数をその値が必要になったときに初めて計算する方式。
遅延計算によって、無限になる可能性のあるデータ構造について限界を明治せずにプログラムすることができる。
関数の引数を関数本体の実行前に計算しても、その結果を使わないことがあるのに対し、遅延宣言型プログラムは結果を得るために最低限の仕事しかしない。

多くの関数型言語はカリー化という高階プログラム技法を備えている。

### 2.8.2 単一化と内含

2.2節で同等操作`=`を使ってどのようにしてデータフロー変数に部分値を束縛したり、変数同士を束縛するのか見た。
変数に値を束縛することは、単一化（unification）といわれる操作の特殊な場合である。
単一化<Term1>=<Term2>において、可能ならば格納域に0個以上の束縛を追加し、部分値<Term1>と部分値<Term2>を等しくすることができる。
2つの項を等しくできなければ、例外が発生する。
部分値があるから単一化に意義があり、完全値しかなければ、単一化は無意味である。

ある変数がある値に等しいかどうかテストすることは、内含チェックおよび反駁チェックの特殊な場合である。
内含チェックおよび反駁チェックは、等、不等が分かるまでブロックする。
内含チェックでは束縛は行わない。

#### 2.8.2.1 単一化

単一化は、単一代入格納域に情報を追加する操作と考えると良い。
格納域はデータフロー変数の集合で、そこでは各値は束縛されていないか、あるいは他の格納域実体に束縛されている。
格納域の情報は、すべての束縛の集合に他ならない。
X=Yという新しい束縛を行えば、XとYが等しいという情報が追加される。
単一化は新しい情報を与えることのできる一種の編集者（compiler）で、既存の束縛を考慮にいれて格納域を編集する。

2つの部分値が両立しない場合は単一化できない。
単一化しようとした場合はfailure例外を発生し、try文に補足される。

#### 2.8.2.2 単一化のアルゴリズム

単一化を正格に定義する。
unify(x, y) を、2つの部分地xとyを格納域σの中で単一化するそうさと定義する。

##### 格納域

格納域はk個の変数x1, …, xkの集合である。
k個の変数は次のように別れる
- 束縛されていない変数の集合
- 数、レコード、または手続きに束縛された変数（決定状態にある変数）

##### 原始的束縛操作

格納域σ上の原始的束縛操作によって単一化を定義する。
この操作は、同値集合内のすべての変数を束縛する

- bind(ES, <v>)
    - 同値集合ESの中のすべての変数に数またはレコード<v>を束縛する
- bind(ES1, ES2)
    - 同値集合ES1と同値集合ES2を併合する

##### アルゴリズム

unify(x, y) を次のように定義する
1. xが同値集合ESxに属し、yが同値集合Eyに属するとすれば、bind(Ex, Ey)が行われる
    (ExとEyが同じ集合であれば何も行われない)
2. xが同値集合ESxに属し、yが決定状態にあれば、bind(Ex, y)が行われる

3. yが同値集合ESyに属し、xが決定状態にあれば、bind(Ey, x)が行われる
4. xがl(l1:x1, …, ln:xn)に束縛され、yがl(l'1:y1, …, l’m:ym)に束縛されていて、l != l’ または {l1, …, ln} != {l'1, …, l’m} であればfaulure例外が発生する

5. xがl(l1:x1, …, ln:xn)に束縛され、yがl(l'1:y1, …, l’n:yn)に束縛されていれば、1からnまでのiについてunify(xi, yi)が行われる

##### 循環的構造の扱い

unify(x, y) で、上のアルゴリズムは循環的構造を持つ部分値を扱おうとすると無限ループになる。
しかし、xとyは全く同じ構造を持っていることは明らかであり、単一化がすべきことは、何もしないこと。
どうしたらいいか？

簡単な解決方法は、2つの変数のあり得る対(x, y)のそれぞれについて、unify(x, y)が1回しか呼ばれないようにすること。
格納域にk個の変数があれば、異なる単一化呼び出しはk^2個である。

新しいアルゴリズムをunify’(x, y)とする。

unify’(x, y) を次のように定義する
1. Mを新しい、空の表とする
2. unify’'(x, y)が呼ばれた際に (x, y)∈Mだったら終わり
3. そうでなければ、(x, y)をMに挿入して、unify(x, y)を実効する
4. unify(x, y)の再帰呼び出しはunify’'に置き換える

Mをunify’’に追加の２つの引数として渡すことによって、宣言的モデルの中でこのアルゴリズムを書くことができる。
将来の呼び出しを避けるために以前の呼び出しを覚えておく表をメモ化表という。

#### 2.8.2.3 循環的構造の表示

local X Y Z in
    f(X b) = f(a Y)
    f(Z a) = Z
    {Browse [X Y X]}
end

// Graph:
// [a b a]
// 
// Minimal Graph
// [a b a]

declare X Y Z in
a(X c(Z) Z) = a(b(Y) Y d(X))
{Browse X#Y#Z}

// Graph:
// b(c(d(b(c(d(b(c(d(,,,)))))))))#
// c(d(b(c(d(b(c(d(b(,,,)))))))))#
// d(b(c(d(b(c(d(b(c(,,,)))))))))
//
// Minimal Graph:
// (C1=b(c(d(C1))))#(C2=c(d(b(C2))))#(C3=d(b(c(C3))))

Minimal Graphは最小のグラフを表示してくれる :)

#### 2.8.2.4 内含チェックと反駁チェック

内含チェックX==Yはブール型関数で、XとYが等しいかどうかテストする。
逆の反駁チェックX\=Yも本質的に同じアルゴリズムを使う。
検証可能な態様で、X=Yを示す情報が格納域にあるとき、内含チェックはtrueを返し、検証可能な態様で格納域がX=Yを示せないとき、falseを返す。
どちらとも決められない場合、内含チェックはブロックする。

内含チェックは次のように定義される
- ノードXおよｂノードYから始まるグラフが同じ構造であれば、（すべての対応するノードが同じ値を持つか、同じノードであれば）trueを返す（構造同等性）
- 2つのグラフが異なる構造を持つとき、あるいは対応するノードのどれかが異なる値を持つとき、falseを返す
- 対応する対の、異なるノードに達して、ノードのどちらも束縛されてる場合以外はブロックする


declare L1 L2 L3 Head Tail in
L1=Head|Tail
Head=1
Tail=2|nil

L2=[1 2]
{Browse L1==L2}

L3='|'(1:1 2:'|'(2 nil))
{Browse L1==L3}

// true
// true


declare L1 L2 X in 
L1=[1]
L2=[X]
{Browse L1==L2}

// …

X=1

//…

X=2

//…


declare L1 L2 X in
L1=[X]
L2=[X]
{Browse L1==L2}

// true

格納域の未束縛の同じ集合だから？


declare L1 L2 X Y in
X=Y
L1=[X]
L2=[Y]
{Browse L1==L2}

// true


declare L1 L2 X in
L1=[1 a]
L2=[X b]
{Browse L1==L2}

// false

### 2.8.3 動的型付けと静的型付け

言語は、その言語によって強制される型システムを持つことが重要。
（弱く型付けされた言語においては、ある型の内部表現がプログラムによって操作できる）
強い型付けに
- 動的型付け
    - 動的型付け言語は、変数に任意の型の実体を束縛できる。したがって変数の型は実行時にしか分からない
- 静的型付け
    - 静的型付け言語は、すべての変数の型はコンパイル時にわかっている
    - 型はプログラマが宣言するか、コンパイラが推測する
がある。

ある言語を設計するときにしなければならない大きな決断の一つは、動的型付けにするか、静的片付けにするか、あるいは、なにか混在的なものにするかの選択である。
それぞれの長所と短所は？

##### 動的型付け

- 書けるプログラムを制限しない
    - 構文的に正しいプログラムはすべて実行できる
    - 型エラーによって例外を発生するプログラムもあるが、例外ハンドラに補足される
- 動的型付けによって、ありとあらゆるプログラミング技法が使える
    - ポリモーフィズム？
- 各モジュールが互いに相手のことを知らずにコンパイルできる
    - 独立に書かれたモジュールが実行時に一緒になり、相互に作用しあう
    - プログラム開発を細分化できる
        - 極度に大きいプログラムをモジュールに分割し、各モジュールを再コンパイルするだけで他は触らないでいい
- プログラムやプログラム片を例え不完全あるいは矛盾のある状態でもテストすることができる

##### 静的型付け

- コンパイル時により多くのプログラムエラーを見つけることができる
    - 静的型宣言はプログラムの部分的仕様とみなせ、プログラムの振舞いの一部を規定している
- 変数がどんな値を持つことができるかをコンパイラが知っているので、ブール型であれば1ビットに実装することができる
    - 動的型付け言語ではコンパイラは常に型を推定できるとは限らない
        - 推定できない場合、どんな値も収容できるようにしないとだめ
- プログラムのセキュリティが向上する
     - 型システムが提供する保護に基づいて初めて安全なデータ抽象が構築できる


両者の選択は理性ではなく感情で行われることが多い。
どちらも実用的なアプリケーションに有効であるので、状況により有効な型付けを選択するべき。
静的型付けと動的型付けの選択は必ずしも100:0である必要はない。
両者のいいとこ取りした言語を設計することは、現在活発に研究されている。

この本に示す計算モデルは、すべて動的型付けOz言語の部分集合である。
Ozプロジェクトの研究目的の1つは、いくつかのプログラミングパラダムを投稿した計算モデルにおいて、どのようなプログラミング技法が可能かを解明することである。
この目的を達成する唯一の方法が動的型付けでしか行えない。
プログラミング技法がわかったら、静的型付けシステムを設計することも考えられる。
実際、Aliceというプロジェクトがあり、Aliceは静的型付けシステムを追加することを選択している。

### 2.9.13 単一化

declare W X Y Z
X = [a Z]
Y = [W b]
X = Y
{Browse W#X#Y#Z}



X = [a Z]
X = Y
{Browse W#X#Y#Z}


declare W X Y Z
Y = [W b]
X = Y

X = [a Z]
{Browse W#X#Y#Z}


declare W X Y Z

X = Y
X = [a Z]
Y = [W b]
{Browse W#X#Y#Z}


declare W X Y Z
X = Y

Y = [W b]
X = [a Z]
{Browse W#X#Y#Z}
